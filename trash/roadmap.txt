
Te armo un roadmap compacto, orientado a que Codex pueda ir fase por fase hasta llegar a:

Scraping de RAVA funcionando.

API de cotizaciones normalizadas.

Agente 3 (recomendador simple) dando señales.

Opcional: Agente 4 (mini optimizador de cartera).

Incluyo para cada fase un prompt para Codex.

Fase 0 – Supuestos de base

Asumo:

App PHP 8, sin framework, estilo FinHub (DDD).

MySQL disponible.

Tenés (o vas a tener) un job HTTP tipo /jobs/... invocable por cron externo.

RAVA: vas a scrapear la página pública de cotizaciones (acciones/CEDEAR) vía HTTP (HTML o JSON si existe endpoint).

Fase 1 – Scraping RAVA + tablas en DB

Objetivo:
Poder traer cotizaciones desde RAVA y guardarlas en tablas propias.

Tareas técnicas:

Crear tablas:

rava_instruments (id, symbol, name, tipo, mercado, moneda, activo=bool).

rava_prices (id, instrument_id, as_of, last, change_abs, change_pct, volume, high, low, open).

Implementar RavaScraper (clase PHP) que:

Haga curl a la URL de RAVA (cotizaciones).

Parse HTML o JSON (según lo que RAVA entregue).

Devuelva un array normalizado de cotizaciones.

Job /jobs/rava_sync.php:

Protegido por job_token.

Llama a RavaScraper, mapea a instrumentos y precios, hace UPSERT.

Devuelve JSON con métricas: filas procesadas, insertadas, actualizadas.

Prompt Fase 1 para Codex

Quiero implementar scraping de cotizaciones de RAVA en mi proyecto PHP (FinHub).
Arquitectura: PHP 8, sin framework, estructura tipo DDD (App/Application, App/Domain, App/Infrastructure, Client/views). Base de datos MySQL.

Necesito que implementes la Fase 1: Scraping RAVA + tablas DB con lo siguiente:

Crear SQL para dos tablas:

rava_instruments con columnas:

id INT UNSIGNED PK AI

symbol VARCHAR(50) UNIQUE NOT NULL

name VARCHAR(255) NOT NULL

type VARCHAR(50) NOT NULL (ej: 'ACCION', 'CEDEAR')

market VARCHAR(50) NOT NULL (ej: 'BCBA')

currency VARCHAR(10) NOT NULL (ej: 'ARS')

is_active TINYINT(1) NOT NULL DEFAULT 1

created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP

rava_prices con columnas:

id INT UNSIGNED PK AI

instrument_id INT UNSIGNED NOT NULL (FK a rava_instruments.id)

as_of DATETIME NOT NULL

last DECIMAL(18,4) NOT NULL

change_abs DECIMAL(18,4) NULL

change_pct DECIMAL(9,4) NULL

volume BIGINT NULL

open DECIMAL(18,4) NULL

high DECIMAL(18,4) NULL

low DECIMAL(18,4) NULL

created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP

índice único en (instrument_id,as_of).

Crear clase App\Infrastructure\Rava\RavaScraper en App/Infrastructure/Rava/RavaScraper.php que:

Use cURL sin librerías externas.

Tenga método fetchRaw(): string que traiga el HTML/JSON de la página de cotizaciones de RAVA (dejá la URL en una constante o configurable).

Tenga método parseQuotes(string $raw): array que devuelva un array de arrays con:

symbol, name, type, market, currency, last, change_abs, change_pct, volume, open, high, low.

Esté preparado para parsear una tabla HTML típica (podés asumir <table> con filas <tr> y celdas <td>, y dejar bien comentado dónde ajustar selectores/XPath si cambia la estructura).

Crear job HTTP jobs/rava_sync.php que:

Incluya bootstrap/autoloader del proyecto.

Valide $_GET['job_token'] contra una constante RAVA_JOB_TOKEN.

Instancie RavaScraper, llame a fetchRaw() y parseQuotes().

Haga UPSERT en rava_instruments (por symbol).

Inserte/actualice en rava_prices según (instrument_id,as_of = NOW).

Devuelva JSON tipo:

{ "ok": true, "row_count": N, "inserted_instruments": X, "updated_instruments": Y, "prices_upserted": Z, "as_of": "YYYY-MM-DD HH:MM:SS" }


Maneje excepciones devolviendo HTTP 500 con { "ok": false, "error": "mensaje" }.

Generá:

el SQL de creación de tablas,

la clase RavaScraper completa,

y el script jobs/rava_sync.php completo, listos para usar.

Fase 2 – API interna de cotizaciones normalizadas

Objetivo:
Poder consumir las cotizaciones de RAVA desde el frontend y desde la futura IA.

Tareas técnicas:

Crear un servicio de aplicación RavaQuoteService que lea de DB:

Último precio por símbolo (por MAX(as_of)).

Filtros opcionales: tipo (ACCION/CEDEAR), texto, paginación.

Endpoint REST /api/quotes/rava:

GET /api/quotes/rava?type=CEDEAR&search=GGAL

Respuesta JSON:

{
  "ok": true,
  "as_of": "2025-11-27 15:00:00",
  "items": [ { "symbol": "...", "name": "...", "last": 123.45, "change_pct": 2.34, ... } ]
}

Prompt Fase 2 para Codex

Ahora quiero la Fase 2: API de cotizaciones RAVA en mi proyecto FinHub.
Partimos de que ya existen las tablas rava_instruments y rava_prices y el job rava_sync.php.

Crear clase App\Application\RavaQuoteService que reciba un PDO en el constructor y exponga un método:

public function getLatestQuotes(?string $type = null, ?string $search = null, int $limit = 100, int $offset = 0): array


Devuelve un array con la última cotización (MAX(as_of)) por instrumento.

Si $type no es null, filtra por rava_instruments.type.

Si $search no es null, filtra por symbol LIKE o name LIKE.

Incluye en cada item: symbol, name, type, market, currency, last, change_abs, change_pct, volume, as_of.

Devuelve también la fecha máxima global (max_as_of) del conjunto.

Crear un controlador/handler para el endpoint GET /api/quotes/rava (ajustarlo al router actual del proyecto) que:

Lea query params type, search, limit, offset.

Llame a RavaQuoteService::getLatestQuotes(...).

Devuelva JSON:

{
  "ok": true,
  "as_of": "YYYY-MM-DD HH:MM:SS",
  "items": [ ... ]
}


En caso de error, HTTP 500 con { "ok": false, "error": "mensaje" }.

Escribí el código completo de RavaQuoteService y del handler/endpoint, consistente con el estilo del proyecto.

Fase 3 – Agente 3: Recomendador simple por instrumento

Objetivo:
Empezar a obtener señales de recomendación por instrumento (BUY / HOLD / SELL con score).

Enfoque minimalista (pero útil):

Para cada símbolo, calcular:

Variación diaria (%).

Volatilidad simple de últimos N días (por ahora, N=10).

Tendance simple: si últimos días vienen en subida o bajada.

Score simple:

Penalizar volatilidad muy alta.

Premiar tendencia positiva moderada.

Evitar compras cuando variación del día ya es exagerada (> +10%).

Tareas técnicas:

Crear RavaRecommendationService:

Lee histórico de rava_prices (N días).

Calcula indicadores sencillos (media, desvío, tendencia, var % actual).

Genera:

score numérico (0–100).

rating textual: "BUY" | "HOLD" | "SELL".

breve reason (string).

Endpoint /api/recommendations/rava:

Puede filtrar por tipo (CEDEAR, ACCION).

Ordenar por score desc.

Prompt Fase 3 para Codex

Fase 3: implementar un servicio de recomendación simple (Agente 3) para instrumentos RAVA.
Partimos de que ya existen rava_instruments, rava_prices y RavaQuoteService.

Crear clase App\Application\RavaRecommendationService con un constructor que reciba PDO.
Métodos:

/**
 * Genera recomendaciones para instrumentos RAVA.
 *
 * @param string|null $type  Tipo de instrumento (ACCION, CEDEAR, etc.) o null para todos.
 * @param int $historyDays   Cantidad de días hacia atrás para calcular indicadores (por defecto 10).
 * @return array             Lista de recomendaciones.
 */
public function getRecommendations(?string $type = null, int $historyDays = 10): array


Para cada instrumento:

Recuperar precios de los últimos $historyDays días (o menos si no hay).

Calcular:

last = último precio

change_pct_today = variación porcentual del último día vs día anterior

volatility = desvío estándar de los retornos diarios en %, en el periodo.

trend = diferencia entre media de últimos 3 días y media de días 4–10 (tendencia simple).

Crear un score 0–100:

Empezar de 50.

Sumar hasta +30 puntos si la tendencia es positiva y la var % no es exagerada.

Restar hasta -30 puntos si la volatilidad es muy alta.

Restar puntos si change_pct_today > +10% (evitar perseguir precios).

Mapear score a rating:

score >= 70 → "BUY"

score <= 40 → "SELL"

en el medio → "HOLD"

Generar una breve reason en texto, basada en las reglas usadas (sin IA, solo lógica).

Devolver array de items con:

symbol, name, type, last, change_pct_today, volatility, trend, score, rating, reason.

Crear endpoint GET /api/recommendations/rava que:

Acepte type como query param.

Llame a RavaRecommendationService::getRecommendations($type).

Devuelva JSON:

{
  "ok": true,
  "generated_at": "YYYY-MM-DD HH:MM:SS",
  "items": [ ... ]
}


Soporte parámetro limit para devolver solo los top N por score.

Escribí la implementación completa de RavaRecommendationService y del handler/endpoint.

Fase 4 – Agente 4 (opcional): mini optimizador de cartera

En vez de un Markowitz full, hacemos algo simple y explicable:

Entrada: posiciones actuales (tabla holdings o similar).

Datos usados:

last, volatility, rating, score del Agente 3.

Salida:

Sugerencia de peso objetivo por instrumento y lista de comprar/vender.

Reglas simples, por ejemplo:

Limitar peso en instrumentos “SELL” (máx. 2–3%).

Aumentar peso en “BUY” hasta un tope (ej. 15%).

Mantener “HOLD” entre 5–10%.

Normalizar a 100%.

Prompt Fase 4 para Codex

Fase 4 (opcional): implementar un mini optimizador de cartera (Agente 4) basado en las recomendaciones de RAVA.

Supuestos:

Existe una tabla holdings con columnas:

id, user_id, symbol, quantity, avg_price, created_at.

Ya implementaste RavaRecommendationService y el endpoint de recomendaciones.

Crear clase App\Application\PortfolioSuggestionService que reciba PDO y RavaRecommendationService en el constructor y exponga:

/**
 * Genera una sugerencia de pesos de cartera para un usuario, basada en las recomendaciones RAVA.
 *
 * @param int $userId
 * @return array
 */
public function suggestTargetAllocation(int $userId): array


Lógica propuesta:

Leer holdings del usuario (symbol, quantity).

Obtener precio last para cada símbolo y calcular position_value.

Calcular total_value.

Obtener recomendaciones para todos los símbolos presentes en la cartera.

Asignar un peso objetivo bruto según rating:

"BUY" → peso base 3

"HOLD" → peso base 2

"SELL" → peso base 1

Ajustar peso por score (por ejemplo: peso_bruto * (score / 50)).

Normalizar todos los pesos objetivo para que sumen 1.0.

Calcular para cada símbolo:

current_weight = valor actual / total_value.

target_weight = peso objetivo normalizado.

delta_weight = target_weight - current_weight.

Devolver array con:

symbol, current_weight, target_weight, delta_weight, rating, score.

Crear endpoint GET /api/portfolio/suggestion?user_id=... que:

Llame a PortfolioSuggestionService::suggestTargetAllocation($userId).

Devuelva JSON con:

{
  "ok": true,
  "user_id": 123,
  "items": [ ... ],
  "generated_at": "YYYY-MM-DD HH:MM:SS"
}


Generá la implementación completa de PortfolioSuggestionService y el handler/endpoint.

Con este roadmap, si vas fase por fase con esos prompts, Codex puede:

Empezar a llenar la DB con datos de RAVA.

Exponerlos por API.

Generar recomendaciones cuantitativas simples (Agente 3).

(Opcional) Proponer una reasignación de cartera (Agente 4).